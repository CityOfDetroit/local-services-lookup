{"version":3,"file":"assets/js/vendors.terraformer-arcgis-parser.js","mappings":"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","sources":["webpack://local-services-lookup/./node_modules/terraformer-arcgis-parser/terraformer-arcgis-parser.js"],"sourcesContent":["/* globals Terraformer */\n(function (root, factory) {\n\n  // Node.\n  if(typeof module === 'object' && typeof module.exports === 'object') {\n    exports = module.exports = factory(require('terraformer'));\n  }\n\n  // Browser Global.\n  if(typeof root.navigator === \"object\") {\n    if (!root.Terraformer){\n      throw new Error(\"Terraformer.ArcGIS requires the core Terraformer library. https://github.com/esri/Terraformer\");\n    }\n    root.Terraformer.ArcGIS = factory(root.Terraformer);\n  }\n\n}(this, function(Terraformer) {\n  var exports = {};\n\n  // https://github.com/Esri/terraformer-arcgis-parser/issues/10\n  function decompressGeometry(str) {\n    var xDiffPrev = 0;\n    var yDiffPrev = 0;\n    var points = [];\n    var x, y;\n    var strings;\n    var coefficient;\n\n    // Split the string into an array on the + and - characters\n    strings = str.match(/((\\+|\\-)[^\\+\\-]+)/g);\n\n    // The first value is the coefficient in base 32\n    coefficient = parseInt(strings[0], 32);\n\n    for (var j = 1; j < strings.length; j += 2) {\n      // j is the offset for the x value\n      // Convert the value from base 32 and add the previous x value\n      x = (parseInt(strings[j], 32) + xDiffPrev);\n      xDiffPrev = x;\n\n      // j+1 is the offset for the y value\n      // Convert the value from base 32 and add the previous y value\n      y = (parseInt(strings[j + 1], 32) + yDiffPrev);\n      yDiffPrev = y;\n\n      points.push([x / coefficient, y / coefficient]);\n    }\n\n    return points;\n  }\n\n  // checks if the first and last points of a ring are equal and closes the ring\n  function closeRing(coordinates) {\n    if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {\n      coordinates.push(coordinates[0]);\n    }\n    return coordinates;\n  }\n\n  // checks if 2 x,y points are equal\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // shallow object clone for feature properties and attributes\n  // from http://jsperf.com/cloning-an-object/2\n  function clone(obj) {\n    var target = {};\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        target[i] = obj[i];\n      }\n    }\n    return target;\n  }\n\n  // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\n  // or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\n  // points-are-in-clockwise-order\n  function ringIsClockwise(ringToTest) {\n    var total = 0,i = 0;\n    var rLength = ringToTest.length;\n    var pt1 = ringToTest[i];\n    var pt2;\n    for (i; i < rLength - 1; i++) {\n      pt2 = ringToTest[i + 1];\n      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);\n      pt1 = pt2;\n    }\n    return (total >= 0);\n  }\n\n  // This function ensures that rings are oriented in the right directions\n  // outer rings are clockwise, holes are counterclockwise\n  function orientRings(poly){\n    var output = [];\n    var polygon = poly.slice(0);\n    var outerRing = closeRing(polygon.shift().slice(0));\n    if(outerRing.length >= 4){\n      if(!ringIsClockwise(outerRing)){\n        outerRing.reverse();\n      }\n\n      output.push(outerRing);\n\n      for (var i = 0; i < polygon.length; i++) {\n        var hole = closeRing(polygon[i].slice(0));\n        if(hole.length >= 4){\n          if(ringIsClockwise(hole)){\n            hole.reverse();\n          }\n          output.push(hole);\n        }\n      }\n    }\n\n    return output;\n  }\n\n  // This function flattens holes in multipolygons to one array of polygons\n  // [\n  //   [\n  //     [ array of outer coordinates ]\n  //     [ hole coordinates ]\n  //     [ hole coordinates ]\n  //   ],\n  //   [\n  //     [ array of outer coordinates ]\n  //     [ hole coordinates ]\n  //     [ hole coordinates ]\n  //   ],\n  // ]\n  // becomes\n  // [\n  //   [ array of outer coordinates ]\n  //   [ hole coordinates ]\n  //   [ hole coordinates ]\n  //   [ array of outer coordinates ]\n  //   [ hole coordinates ]\n  //   [ hole coordinates ]\n  // ]\n  function flattenMultiPolygonRings(rings){\n    var output = [];\n    for (var i = 0; i < rings.length; i++) {\n      var polygon = orientRings(rings[i]);\n      for (var x = polygon.length - 1; x >= 0; x--) {\n        var ring = polygon[x].slice(0);\n        output.push(ring);\n      }\n    }\n    return output;\n  }\n\n  function coordinatesContainCoordinates(outer, inner){\n    var intersects = Terraformer.Tools.arraysIntersectArrays(outer, inner);\n    var contains = Terraformer.Tools.coordinatesContainPoint(outer, inner[0]);\n    if(!intersects && contains){\n      return true;\n    }\n    return false;\n  }\n\n  // do any polygons in this array contain any other polygons in this array?\n  // used for checking for holes in arcgis rings\n  function convertRingsToGeoJSON(rings){\n    var outerRings = [];\n    var holes = [];\n    var x; // iterator\n    var outerRing; // current outer ring being evaluated\n    var hole; // current hole being evaluated\n\n    // for each ring\n    for (var r = 0; r < rings.length; r++) {\n      var ring = closeRing(rings[r].slice(0));\n      if(ring.length < 4){\n        continue;\n      }\n      // is this ring an outer ring? is it clockwise?\n      if(ringIsClockwise(ring)){\n        var polygon = [ ring.slice().reverse() ]; // wind outer rings counterclockwise for RFC 7946 compliance\n        outerRings.push(polygon); // push to outer rings\n      } else {\n        holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance\n      }\n    }\n\n    var uncontainedHoles = [];\n\n    // while there are holes left...\n    while(holes.length){\n      // pop a hole off out stack\n      hole = holes.pop();\n\n      // loop over all outer rings and see if they contain our hole.\n      var contained = false;\n      for (x = outerRings.length - 1; x >= 0; x--) {\n        outerRing = outerRings[x][0];\n        if(coordinatesContainCoordinates(outerRing, hole)){\n          // the hole is contained push it into our polygon\n          outerRings[x].push(hole);\n          contained = true;\n          break;\n        }\n      }\n\n      // ring is not contained in any outer ring\n      // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320\n      if(!contained){\n        uncontainedHoles.push(hole);\n      }\n    }\n\n    // if we couldn't match any holes using contains we can now try intersects...\n    while(uncontainedHoles.length){\n      // pop a hole off out stack\n      hole = uncontainedHoles.pop();\n\n      // loop over all outer rings and see if any intersect our hole.\n      var intersects = false;\n      for (x = outerRings.length - 1; x >= 0; x--) {\n        outerRing = outerRings[x][0];\n        if(Terraformer.Tools.arraysIntersectArrays(outerRing, hole)){\n          // the hole intersects the outer ring push it into our polygon\n          outerRings[x].push(hole);\n          intersects = true;\n          break;\n        }\n      }\n\n      // hole does not intersect ANY outer ring at this point\n      // make it an outer ring.\n      if(!intersects) {\n        outerRings.push([hole.reverse()]);\n      }\n    }\n\n    if(outerRings.length === 1){\n      return {\n        type: 'Polygon',\n        coordinates: outerRings[0]\n      };\n    } else {\n      return {\n        type: 'MultiPolygon',\n        coordinates: outerRings\n      };\n    }\n  }\n\n  // ArcGIS -> GeoJSON\n  function parse(arcgis, options){\n    var geojson = {};\n\n    options = options || {};\n    options.idAttribute = options.idAttribute || undefined;\n\n    if (arcgis.spatialReference && (arcgis.spatialReference.wkid === 3857 || arcgis.spatialReference.wkid === 102100)) {\n      geojson.crs = Terraformer.MercatorCRS;\n    }\n\n    if(typeof arcgis.x === 'number' && typeof arcgis.y === 'number'){\n      geojson.type = \"Point\";\n      geojson.coordinates = [arcgis.x, arcgis.y];\n      if (arcgis.z || arcgis.m){\n        geojson.coordinates.push(arcgis.z);\n      }\n      if (arcgis.m){\n        geojson.coordinates.push(arcgis.m);\n      }\n    }\n\n    if(arcgis.points){\n      geojson.type = \"MultiPoint\";\n      geojson.coordinates = arcgis.points.slice(0);\n    }\n\n    if(arcgis.paths) {\n      if(arcgis.paths.length === 1){\n        geojson.type = \"LineString\";\n        geojson.coordinates = arcgis.paths[0].slice(0);\n      } else {\n        geojson.type = \"MultiLineString\";\n        geojson.coordinates = arcgis.paths.slice(0);\n      }\n    }\n\n    if(arcgis.rings) {\n      geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n    }\n\n    if(\n      typeof arcgis.xmin === \"number\" &&\n      typeof arcgis.ymin === \"number\" &&\n      typeof arcgis.xmax === \"number\" &&\n      typeof arcgis.ymax === \"number\"\n    ) {\n      geojson.type = \"Polygon\";\n      geojson.coordinates = [[\n        [arcgis.xmax, arcgis.ymax],\n        [arcgis.xmin, arcgis.ymax],\n        [arcgis.xmin, arcgis.ymin],\n        [arcgis.xmax, arcgis.ymin],\n        [arcgis.xmax, arcgis.ymax]\n      ]];\n    }\n\n    if(arcgis.compressedGeometry || arcgis.geometry || arcgis.attributes) {\n      geojson.type = \"Feature\";\n\n      if(arcgis.compressedGeometry){\n        arcgis.geometry = {\n          paths: [\n            decompressGeometry(arcgis.compressedGeometry)\n          ]\n        };\n      }\n\n      geojson.geometry = (arcgis.geometry) ? parse(arcgis.geometry) : null;\n      geojson.properties = (arcgis.attributes) ? clone(arcgis.attributes) : null;\n      if(arcgis.attributes) {\n        geojson.id =  arcgis.attributes[options.idAttribute] || arcgis.attributes.OBJECTID || arcgis.attributes.FID;\n      }\n    }\n\n    return new Terraformer.Primitive(geojson);\n  }\n\n  // GeoJSON -> ArcGIS\n  function convert(geojson, options){\n    var spatialReference;\n\n    options = options || {};\n    var idAttribute = options.idAttribute || \"OBJECTID\";\n\n    if(options.sr){\n      spatialReference = { wkid: options.sr };\n    } else if (geojson && geojson.crs && geojson.crs.properties.name != \"urn:ogc:def:crs:OGC:1.3:CRS84\") {\n      spatialReference = null;\n    } else {\n      spatialReference = { wkid: 4326 };\n    }\n\n    var result = {};\n    var i;\n\n    switch(geojson.type){\n    case \"Point\":\n      result.x = geojson.coordinates[0];\n      result.y = geojson.coordinates[1];\n      if(geojson.coordinates[2]) {\n        result.z = geojson.coordinates[2];\n      }\n      if(geojson.coordinates[3]) {\n        result.m = geojson.coordinates[3];\n      }\n      result.spatialReference = spatialReference;\n      break;\n    case \"MultiPoint\":\n      result.points = geojson.coordinates.slice(0);\n      result.spatialReference = spatialReference;\n      break;\n    case \"LineString\":\n      result.paths = [geojson.coordinates.slice(0)];\n      result.spatialReference = spatialReference;\n      break;\n    case \"MultiLineString\":\n      result.paths = geojson.coordinates.slice(0);\n      result.spatialReference = spatialReference;\n      break;\n    case \"Polygon\":\n      result.rings = orientRings(geojson.coordinates.slice(0));\n      result.spatialReference = spatialReference;\n      break;\n    case \"MultiPolygon\":\n      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n      result.spatialReference = spatialReference;\n      break;\n    case \"Feature\":\n      if(geojson.geometry) {\n        result.geometry = convert(geojson.geometry, options);\n      }\n      result.attributes = (geojson.properties) ? clone(geojson.properties) : {};\n      if(geojson.id) {\n        result.attributes[idAttribute] = geojson.id;\n      }\n      break;\n    case \"FeatureCollection\":\n      result = [];\n      for (i = 0; i < geojson.features.length; i++){\n        result.push(convert(geojson.features[i], options));\n      }\n      break;\n    case \"GeometryCollection\":\n      result = [];\n      for (i = 0; i < geojson.geometries.length; i++){\n        result.push(convert(geojson.geometries[i], options));\n      }\n      break;\n    }\n\n    return result;\n  }\n\n  function parseCompressedGeometry(string){\n    return new Terraformer.LineString(decompressGeometry(string));\n  }\n\n  exports.parse   = parse;\n  exports.convert = convert;\n  exports.toGeoJSON = parse;\n  exports.fromGeoJSON = convert;\n  exports.parseCompressedGeometry = parseCompressedGeometry;\n\n  return exports;\n}));\n"],"names":["root","factory","module","exports","navigator","Terraformer","Error","ArcGIS","this","decompressGeometry","str","x","y","strings","coefficient","xDiffPrev","yDiffPrev","points","match","parseInt","j","length","push","closeRing","coordinates","a","b","i","pointsEqual","clone","obj","target","hasOwnProperty","ringIsClockwise","ringToTest","pt2","total","rLength","pt1","orientRings","poly","output","polygon","slice","outerRing","shift","reverse","hole","coordinatesContainCoordinates","outer","inner","intersects","Tools","arraysIntersectArrays","contains","coordinatesContainPoint","parse","arcgis","options","geojson","idAttribute","undefined","spatialReference","wkid","crs","MercatorCRS","type","z","m","paths","rings","outerRings","holes","r","ring","uncontainedHoles","pop","contained","convertRingsToGeoJSON","xmin","ymin","xmax","ymax","compressedGeometry","geometry","attributes","properties","id","OBJECTID","FID","Primitive","convert","sr","name","result","flattenMultiPolygonRings","features","geometries","toGeoJSON","fromGeoJSON","parseCompressedGeometry","string","LineString"],"sourceRoot":""}